# 浏览器

* [浏览器 进程 vs 线程](#浏览器-进程-vs-线程)
* [HTTP 发展](#http-发展)
  * [HTTP/0.9](#http09)
  * [HTTP/1.0](#http10)
  * [HTTP/1.1](#http11)
    * [局限性](#局限性)
  * [HTTP/2](#http2)
    * [局限性](#局限性-1)
  * [HTTP/3](#http3)
  * [扩展——TCP的“三次握手”和“四次挥手”](#扩展tcp的三次握手和四次挥手)
  * [总结](#总结)
* [HTTP 缓存](#http-缓存)
    * [强制缓存](#强制缓存)
    * [协商缓存](#协商缓存)
    * [总结](#总结-1)
* [跨域方案](#跨域方案)
  * [浏览器的同源策略（Same Origin Policy）](#浏览器的同源策略same-origin-policy)
  * [请求跨域解决方案](#请求跨域解决方案)
    * [跨域资源共享](#跨域资源共享)
    * [JSONP](#jsonp)
    * [Websocket](#websocket)
    * [代理转发](#代理转发)
  * [页面跨域解决方案](#页面跨域解决方案)
    * [postMessage](#postmessage)
    * [改域](#改域)
* [参考](#参考)

## 浏览器 进程 vs 线程

进程是操作系统进行资源分配和调度的基本单位，线程是操作系统进行运算的最小单位。一个程序至少有一个进程，一个进程至少有一个线程。线程需要由进程来启动和管理。

不同进程之间的资源是独享的，不可以相互访问。
而多线程没有分配独立的资源，线程之间数据都是共享的，也就意味着创建线程的成本更小，因为不需要分配额外的存储空间。
但线程的数据共享也带来了很多问题：首先是稳定性，进程中任意线程崩溃都会导致整个进程的崩溃，也就是说会“牵连”到进程中的其他线程。安全隐患就更容易理解了，如果有恶意线程启动，可以随意访问进程中的任意资源。

结论：多线程更轻量，多进程更安全更稳定。

以 Chrome 为例介绍浏览器的进程

- 浏览器进程
- GPU 进程
- Network Service 进程
- V8 代理解析工具进程
- 渲染进程
- 扩展程序进程
- 进程的服务化

## HTTP 发展

### HTTP/0.9

1991 年 HTTP 正式诞生，当时的版本是 0.9，从名字可以看出，该协议的作用是传输超文本内容 HTML。

### HTTP/1.0

随着互联网的发展以及浏览器的出现，单纯的文本内容已经无法满足用户需求了，浏览器希望通过 HTTP 来传输脚本、样式、图片、音频和视频等不同类型的文件。

所以在 1996 年 HTTP 更新的 1.0 版本中，针对上述问题，作出了重大改变。

其中最核心的改变是增加了头部设定，头部内容以键值对的形式设置。请求头部通过 Accept 字段来告诉服务端可以接收的文件类型，响应头部再通过 Content-Type 字段来告诉浏览器返回文件的类型。

这同时也是一个相当具有前瞻性的设计，因为头部字段不仅用于解决不同类型文件传输的问题，而且其他很多功能也可以依靠头部字段实现，比如缓存、认证信息。

### HTTP/1.1

随着互联网的迅速发展，HTTP/1.0 也已经无法满足需求，最核心的就是连接问题。具体来说就是 HTTP/1.0 每进行一次通信，都需要经历建立连接、传输数据和断开连接三个阶段。当一个页面引用了较多的外部文件时，这个建立连接和断开连接的过程就会增加大量网络开销。

为了解决这个问题，1999 年推出的 HTTP/1.1 版本增加了一个创建持久连接的方法。主要实现是当一个连接传输完成时，并不是马上进行关闭，而是继续复用它传输其他请求的数据，这个连接保持到浏览器或者服务器要求断开连接为止。

#### 局限性

- **浏览器为了减轻服务器的压力**，限制了同一个域下的 HTTP 连接数，即 6 ~ 8 个，所以在 HTTP/1.1 下很容易看到资源文件等待加载的情况，对应优化的方式就是使用多个域名来加载图片资源；
- **HTTP/1.1 本身的问题**，虽然 HTTP/1.1 中使用持久连接时，多个请求能共用一个 TCP 连接，但在一个连接中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态，这种情况被称为 **“队头阻塞”** 。

### HTTP/2

HTTP/1.1 虽然通过长连接减少了大量创建/断开连接造成的性能消耗，但由于它的并发能力受到限制，所以传输性能还有很大提升空间。为了解决这个问题，在 2015 年正式发布的 HTTP/2 中新增了一个二进制分帧的机制来提升传输效率。

HTTP/2 将默认**不再使用 ASCII 编码传输，而是改为二进制数据**。客户端在发送请求时会将每个请求的内容封装成不同的带有编号的二进制帧，然后将这些帧同时发送给服务端。服务端接收到数据之后，会将相同编号的帧合并为完整的请求信息。同样，服务端返回结果、客户端接收结果也遵循这个帧的拆分与组合的过程。

受益于二进制分帧，对于同一个域，客户端只需要与服务端建立一个连接即可完成通信需求，自然也不再受限于浏览器的连接数限制了，这种利用一个连接来发送多个请求的方式称为“**多路复用**”。

HTTP/2 也增加了一些其他的功能，比如通过压缩头部信息来减少传输体积，以及通过服务推送来减少客户端请求。

#### 局限性

HTTP/2 由于采用二进制分帧进行多路复用，通常只使用一个 TCP 连接进行传输，在丢包或网络中断的情况下后面的所有数据都被阻塞。也就是客户端或服务端任何一方丢包或者网络出现中断，那么整个 TCP 连接就会暂停。

### HTTP/3

2018 年 HTTP/3 将底层依赖的 TCP 改成 UDP，从而彻底解决了 HTTP/2 基于 TCP 的局限性。UDP 相对于 TCP 而言最大的特点是传输数据时不需要建立连接，可以同时发送多个数据包，所以传输效率很高，缺点就是没有确认机制来保证对方一定能收到数据。

### 扩展——TCP的“三次握手”和“四次挥手”

three-way handshake: SYN, SYN + ACK, ACK

four-way handshake: FIN, ACK, FIN + ACK, ACK

![tcp-handshake-state](https://res-static.hc-cdn.cn/fms/img/858c53a36898590f06378f5087854fc31603447450545)

(图片来源于网络)

**半连接队列**

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

补充一点关于SYN-ACK 重传次数的问题：

服务器发送完 SYN-ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。每次重传等待的时间一般会是指数增长，例如间隔时间为 1s，2s，4s，8s …

**全连接队列**

已经完成三次握手，建立起请求连接的就会放在全连接队列中，如果队列满了就有可能会出现丢包现象。

**SYN flood attack**
- 客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送 SYN；
- 服务器端处理大量的 SYN 包并返回对应 ACK, 大量连接处于 SYN_RCVD 状态，占满整个半连接队列，无法处理正常的请求；
- 由于是不存在的 IP，服务端长时间收不到客户端的 ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。

查看命令

```shell
netstat -n -p TCP | grep SYN_RECV
```

**为什么建立连接只通信了三次，而断开连接却用了四次？**

这由 TCP 的半关闭（half-close）造成的。所谓的半关闭，其实就是 TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

当服务端收到客户端的 FIN 报文后，发送的 ACK 报文只是用来应答的，并不表示服务端也希望立即关闭连接。
只有服务端把所有的报文都发送完了，才会发送 FIN 报文，告诉客户端可以断开连接了。
这样就是四次挥手了。

**2ML**

Maximum Segment Lifetime 最长报文段寿命，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

为了保证客户端发送的最后一个 ACK 报文段能够到达服务器。因为这个 ACK 有可能丢失，从而导致处在 LAST-ACK 状态的服务器收不到对 FIN-ACK 的确认报文。服务器会超时重传这个 FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待 2MSL，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态。

客户端的 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。

### 总结

| **协议版本** | **解决的核心问题**       | **解决方式**                           |
| :----------: | -------------------- | ------------------------------- |
| 0.9          | HTML 文本传输          | 确立了客户端请求、服务端响应的通信流程 |
| 1.0          | 不同类型文件传输         | 设立头部字段                      |
| 1.1          | 创建/断开 TCP 连接开销大 | 建立长连接以复用连接                |
| 2            | 并发数受限              | 二进制分帧                        |
| 3            | TCP 丢包阻塞            | 采用 UDP 协议                    |

## HTTP 缓存

HTTP 支持的缓存策略有两种：**强制缓存**和**协商缓存**。

#### 强制缓存

强制缓存是在浏览器加载资源的时候，先直接从缓存中查找请求结果，如果不存在该缓存结果，则直接向服务端发起请求。

有两个设置与此有关

1. Expires

   HTTP/1.0 时期的，局限性是服务器和客户端时间的不一致性。
   
   >其值是一个 date 格式，如：Wed, 11 Aug 2021 08:36:18 GMT

2. Cache-Control

   HTTP/1.1 提出了 Cache-Control 响应头部字段，可以解决 Expires 的时间不一致问题。

   常用值及含义

   |      Value      | Description                                                  |
   | :-------------: | ------------------------------------------------------------ |
   |    no-cache     | 表示使用**协商缓存**，即每次使用缓存前必须向服务端确认缓存资源是否更新 |
   |    no-store     | 禁止浏览器以及所有中间缓存存储响应内容                    |
   |     public      | 公有缓存，表示可以被代理服务器缓存，可以被多个用户共享       |
   |     private     | 私有缓存，不能被代理服务器缓存，不可以被多个用户共享         |
   |     max-age     | 以秒为单位的数值，表示缓存的有效时间                      |
   | must-revalidate | 当缓存过期时，需要去服务端校验缓存的有效性                 |

   这几个值可以组合使用

   ```ini
   # 公有缓存，有效期一天
   cache-control: public, max-age=86400
   ```

>如果同时设置了 expires 和 cache-control max-age，浏览器会使用 max-age 的设置，因为 cache-control 的 max-age 优先级高于 expires。
>

#### 协商缓存

协商缓存的更新策略是不再指定缓存的有效时间了，而是浏览器直接发送请求到服务端进行确认缓存是否更新，如果请求响应返回的 HTTP 状态为 304，则表示缓存仍然有效。控制缓存的难题就是从浏览器端转移到了服务端。

有关设置

- Last-Modified 响应头部 和 If-Modified-Since 请求头部

  局限性：依赖于依赖于修改时间，有精度问题和准度问题

- ETag 和 If-None-Match

  不依赖于修改时间，而依赖于文件哈希值的精确判断缓存的方式，那就是响应头部字段 ETag 和请求头部字段 If-None-Match。

  局限性：计算成本 和 计算误差

#### 总结

- 强制缓存的优先级高于协商缓存；
- 在强制缓存中，max-age 优先级高于 expires ；
- 在协商缓存中，Etag 优先级高于 Last-Modified 。

## 跨域方案

### 浏览器的同源策略（Same Origin Policy）

源（Origin）是由 URL 中协议(scheme)、主机名（域名 domain）以及端口共同组成的部分。

![URL](https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL/mdn-url-all.png)

当一个源访问另一个源的资源时就会产生**跨源**。同源策略就是用来限制其中一些跨源访问的，包括访问 iframe 中的页面、其他页面的 cookie 访问以及发送 AJAX 请求。最常见的跨源场景是域名不同，即常说的“跨域”。

### 请求跨域解决方案

推荐优先使用**代理转发** 和 **跨域资源共享**。

#### 跨域资源共享

跨域资源共享（CORS，Cross-Origin Resource Sharing）是浏览器为 AJAX 请求设置的一种跨域机制，让其可以在服务端允许的情况下进行跨域访问。主要通过 HTTP 响应头来告诉浏览器服务端是否允许当前域的脚本进行跨域访问。

跨域资源共享将 AJAX 请求分成了两类：简单请求和非简单请求。其中**简单请求**符合下面 2 个特征。

- 请求方法为 GET、POST、HEAD。

- 请求头只能使用下面的字段：

  - Accept（浏览器能够接受的响应内容类型）

  - Accept-Language（浏览器能够接受的自然语言列表）

  - Content-Type （请求对应的类型，只限于 text/plain、multipart/form-data、application/x-www-form-urlencoded）

  - Content-Language（浏览器希望采用的自然语言）

  - Save-Data（浏览器是否希望减少数据传输量）

> **任意一条要求不符合的即为非简单请求。**

对于简单请求，处理流程如下：

- 浏览器发出简单请求的时候，会在请求头部增加一个 Origin 字段，对应的值为当前请求的源信息；
- 当服务端收到请求后，会根据请求头字段 Origin 做出判断后返回相应的内容。
- 浏览器收到响应报文后会根据响应头部字段 Access-Control-Allow-Origin 进行判断，这个字段值为服务端允许跨域请求的源，其中通配符“*”表示允许所有跨域请求。如果头部信息没有包含 Access-Control-Allow-Origin 字段或者响应的头部字段 Access-Control-Allow-Origin 不允许当前源的请求，则会抛出错误。

对于非简单请求，处理流程如下：

- 浏览器会先发出一个**预检请求（Preflight）**。这个预检请求为 `OPTIONS` 方法，并会添加了 1 个请求头部字段 `Access-Control-Request-Method`，值为跨域请求所使用的请求方法。

- 在服务端收到预检请求后，除了在响应头部添加 `Access-Control-Allow-Origin` 字段之外，至少还会添加 `Access-Control-Allow-Methods` 字段来告诉浏览器服务端允许的请求方法，并返回 *204 状态码*。如果浏览器发送了请求头部字段`Access-Control-Request-Headers`，服务端则会添加 `Access-Control-Allow-Headers`  来告诉浏览器服务端允许的请求头部字段。
- 浏览器得到预检请求响应的头部字段之后，会判断当前请求服务是否在服务端许可范围之内，如果在则继续发送跨域请求，反之则直接报错。

#### JSONP

JSONP（JSON with Padding）的大概意思就是用 JSON 数据来填充，怎么填充呢？结合它的实现方式可以知道，就是把 JSON 数填充到一个回调函数中。这种比较 hack 的方式，依赖的是 script 标签跨域引用 js 文件不会受到浏览器同源策略的限制。

#### Websocket

Websocket 是 HTML5 规范提出的一个应用层的全双工协议，适用于浏览器与服务器进行实时通信场景。

全双工，这是通信传输的一个术语。“双工”是指从客户端到服务端，以及从服务端到客户端两个方向都可以通信；“全”指的是通信双方可以同时向对方发送数据。

与之相对应的还有半双工和单工。半双工指的是双方可以互相向对方发送数据，但双方不能同时发送；单工则指的是数据只能从一方发送到另一方。

#### 代理转发

跨域是为了突破浏览器的同源策略限制，既然同源策略只存在于浏览器，那可以换个思路，在服务端进行跨域，比如设置代理转发。这种在服务端设置的代理称为“**反向代理**”。

另一种在客户端使用的代理称为“**正向代理**”，主要用来代理客户端发送请求，用户使用时必须配置代理服务器的网址，比如常用的 VPN 工具就属于正向代理。

举例，

webpack-dev-server proxy 配置正向代理

```javascript
module.exports = {
  //...
  devServer: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
}
```

nginx 配置正/反向代理

```config
location /api {
  proxy_pass http://localhost:3000;
}
```

>正向代理：隐藏了用户，用户的请求被代理服务器接收代替，到了服务器，服务器并不知道用户是谁。
>1. 用户发送请求到自己的代理服务器
>2. 自己的代理服务器发送请求到服务器
>3. 服务器将数据返回到自己的代理服务器
>4. 自己的代理服务器再将数据返回给用户
>
>反向代理：用户请求过多，服务器会有一个处理的极限。所以使用反向代理服务器接受请求，再用均衡负载将请求分发给多个真实的服务器。既能提高效率还有一定的安全性。
>1. 用户发送请求到服务器（访问的其实是反向代理服务器，但用户不知道）
>2. 反向代理服务器发送请求到真正的服务器
>3. 真正的服务器将数据返回给反向代理服务器
>4. 反向代理服务器再将数据返回给用户
>
>总结：正向代理隐藏的是用户，反向代理隐藏的是服务器
>

### 页面跨域解决方案

除了浏览器请求跨域之外，页面之间也会有跨域需求，例如使用 iframe 时父子页面之间进行通信。

#### postMessage

HTML5 推出了一个新的函数 postMessage() 用来实现父子页面之间通信，而且不论这两个页面是否同源。

举例来说，比如父页面 http://localhost:1234/parent.html 要向子页面 http://localhost:5678/child.html 发消息

```javascript
// parent page
var child = window.open('http://localhost:5678/child.html', 'child');
  // 父页面可以监听 "message" 事件来接收子页面发送的数据
  window.addEventListener('message', function (e) {
    console.log('reply from child:', e.data);
  }, false);

(function () {
  document.querySelector('input').addEventListener('click', function () {
    child.postMessage('hi', 'http://localhost:5678');
  }, false)

})()

// child page
// 子页面监听 "message" 事件可得到父页面发来的数据
window.addEventListener('message', function (e) {
  console.log('message from parent:', e.data);

  if (e.data === 'hi') {
    // 子页面通过 window.opener 回复消息 hello 给父页面
    window.opener.postMessage('hello', 'http://localhost:1234');
  }
}, false);
```

参考[代码](./page-cross-domain/)

#### 改域

对于主域名相同，子域名不同的情况，可以通过修改 document.domain 的值来进行跨域。

举例说明，
父页面 https://www.abc.com/parent.html 里面有一个 iframe，其 src 是 https://assets.abc.com/child.html。
这时只要把这两个页面的 document.domain 都设成相同的域名 abc.com，那么父子页面之间就可以进行跨域通信了，同时还可以共享 cookie。

## 参考

- [TCP三次握手，四次挥手](https://www.huaweicloud.com/articles/a5ade3fe6835161e23ff064dc8f5e1f9.html)
